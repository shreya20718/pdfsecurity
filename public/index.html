<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OptiFocus - Auto Capture System</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #1a1a1a;
      color: #fff;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #4CAF50;
    }
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      background: #2a2a2a;
      padding: 10px;
      border-radius: 8px;
    }
    .tab {
      padding: 12px 24px;
      background: #3a3a3a;
      border: 2px solid #555;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 600;
    }
    .tab:hover { background: #4a4a4a; }
    .tab.active {
      background: #4CAF50;
      border-color: #4CAF50;
    }
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    button {
      padding: 10px 20px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
    }
    button:hover { background: #45a049; }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    button.secondary {
      background: #2196F3;
    }
    button.secondary:hover {
      background: #0b7dda;
    }
    button.danger {
      background: #f44336;
    }
    button.danger:hover {
      background: #da190b;
    }
    button.camera-switch {
      background: #FF9800;
    }
    button.camera-switch:hover {
      background: #F57C00;
    }
    #viewport {
      position: relative;
      width: 100%;
      max-width: 960px;
      margin: 0 auto;
      background: #000;
      border: 2px solid #4CAF50;
      border-radius: 8px;
      overflow: hidden;
    }
    video, canvas, #capturedImg {
      display: block;
      width: 100%;
      height: auto;
    }
    video {
      position: absolute;
      top: 0;
      left: 0;
    }
    canvas {
      position: relative;
      z-index: 1;
      cursor: crosshair;
    }
    #capturedImg {
      position: absolute;
      top: 0;
      left: 0;
      display: none;
      z-index: 0;
    }
    #log {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 6px;
      margin-top: 20px;
      max-height: 200px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .instructions {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 15px;
      border-left: 4px solid #4CAF50;
    }
    .instructions h3 {
      margin-bottom: 8px;
      color: #4CAF50;
    }
    .instructions ul {
      margin-left: 20px;
      line-height: 1.8;
    }
    .stable-indicator {
      background: #2a2a2a;
      padding: 10px 15px;
      border-radius: 6px;
      margin-bottom: 15px;
      text-align: center;
      font-weight: 600;
      border: 2px solid #666;
    }
    .stable-indicator.stable {
      background: #1b5e20;
      border-color: #4CAF50;
      color: #4CAF50;
    }
    .stable-indicator.capturing {
      background: #f57c00;
      border-color: #ff9800;
      color: #fff;
      animation: pulse 0.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>OptiFocus - Auto Capture System</h1>
   
    <div class="tabs">
      <div class="tab active" data-tab="pupil">Pupil Detector</div>
      <div class="tab" data-tab="frame">Frame Fitter</div>
    </div>

    <div id="pupil-tab" class="tab-content active">
      
     
      <div class="stable-indicator" id="pupil-stable">
        Align your face
      </div>

      <div class="controls">
        <button id="start-pupil">Start Camera</button>
        <button id="switch-camera-pupil" class="camera-switch" disabled>Switch Camera</button>
        <button id="retake-pupil" class="secondary" disabled style="display:none;">Retake Photo</button>
        <button id="reset-auto">Reset Manual (R)</button>
        <button id="save-pupil" class="danger" disabled>Save Result</button>
        <button id="stop-pupil">Stop</button>
      </div>
    </div>

    <div id="frame-tab" class="tab-content">
      
     
      <div class="stable-indicator" id="frame-stable">
        Keep stable
      </div>
     
      <div class="controls">
        <button id="start-frame">Start Camera</button>
        <button id="switch-camera-frame" class="camera-switch" disabled>Switch Camera</button>
        <button id="retake-frame" class="secondary" disabled style="display:none;">Retake Photo</button>
        <button id="toggle-frame" disabled>Toggle Frame (Left)</button>
        <button id="reset-frame">Reset Lines</button>
        <button id="save-frame" class="danger" disabled>Save Result</button>
        <button id="stop-frame">Stop</button>
      </div>
    </div>

    <div id="viewport">
      <video id="video" autoplay playsinline muted></video>
      <img id="capturedImg" />
      <canvas id="overlay"></canvas>
    </div>

    <h3 style="margin-top: 20px;">Measurement Log</h3>
    <pre id="log"></pre>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>
  <script>
    const state = {
      currentTab: 'pupil',
      running: false,
      faceMesh: null,
      animationId: null,
      photoMode: false,
      capturedImage: null,
      capturedLandmarks: null,
      lastMeasurement: null,
      currentCamera: 'user',
      alignmentHoldFrames: 0,
      autoCapturing: false
    };

    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const capturedImg = document.getElementById('capturedImg');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');

    const W = 960, H = 720;
    canvas.width = W;
    canvas.height = H;

    const PUPIL_HOLD_FRAMES = 90; // 3 seconds at 30fps
    const FRAME_HOLD_FRAMES = 60; // 2 seconds at 30fps

    function log(msg) {
      const time = new Date().toLocaleTimeString();
      logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
    }

    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tabName}-tab`).classList.add('active');
        state.currentTab = tabName;
       
        if (state.running) {
          stopCamera();
        }
      });
    });

    // ==================== PUPIL DETECTOR ====================
    const pupilDetector = {
      LEFT_EYE_IDX: [362, 385, 387, 263, 373, 386],
      RIGHT_EYE_IDX: [33, 160, 158, 133, 153, 159],
      LEFT_IRIS_INDICES: [468, 469, 470, 471, 472],
      RIGHT_IRIS_INDICES: [473, 474, 475, 476, 477],
      IRIS_REAL_MM: 11.7,
      FOCAL_PX: 850,
      HEAD_TILT_LIMIT_DEG: 6.0,

      manualLeftPupil: null,
      manualRightPupil: null,
      autoLeftPupil: null,
      autoRightPupil: null,
      selectedEye: null,
      isDragging: false,

      dist(a, b) {
        if (!a || !b) return 0;
        return Math.hypot(a[0] - b[0], a[1] - b[1]);
      },

      calculatePupilCenter(lm, irisIndices) {
        const points = irisIndices.map(idx => [lm[idx].x * W, lm[idx].y * H]);
        const centerPoint = points[0];
        const edgePoints = points.slice(1);
       
        let sumX = centerPoint[0] * 3;
        let sumY = centerPoint[1] * 3;
       
        edgePoints.forEach(p => {
          sumX += p[0];
          sumY += p[1];
        });
       
        const totalWeight = 3 + edgePoints.length;
        return [sumX / totalWeight, sumY / totalWeight];
      },

      validatePupilDetection(lm, leftPupil, rightPupil) {
        if (!leftPupil || !rightPupil) return false;
        const pixelDist = this.dist(leftPupil, rightPupil);
        return pixelDist > 40 && pixelDist < 200;
      },

      processLiveView(lm) {
        const center = [W / 2, H / 2];
        const axisX = W * 0.23, axisY = H * 0.40;
       
        const foreheadLandmark = lm[10];
        const foreheadCenter = [foreheadLandmark.x * W, foreheadLandmark.y * H];
        const foreheadTargetY = center[1] - (axisY * 0.7);
        const foreheadAligned = this.dist(foreheadCenter, [center[0], foreheadTargetY]) < 40;

        const stableIndicator = document.getElementById('pupil-stable');
       
        if (foreheadAligned && !state.autoCapturing) {
          state.alignmentHoldFrames++;
          const progress = Math.min(100, (state.alignmentHoldFrames / PUPIL_HOLD_FRAMES) * 100);
         
          if (state.alignmentHoldFrames >= PUPIL_HOLD_FRAMES) {
            state.autoCapturing = true;
            stableIndicator.textContent = 'ðŸ“¸ Capturing...';
            stableIndicator.classList.add('capturing');
            setTimeout(() => {
              capturePhoto();
              state.autoCapturing = false;
              state.alignmentHoldFrames = 0;
            }, 100);
          } else {
            stableIndicator.textContent = `Hold steady... ${Math.round(progress)}%`;
            stableIndicator.classList.add('stable');
          }
        } else {
          state.alignmentHoldFrames = 0;
          if (!state.autoCapturing) {
            stableIndicator.textContent = 'Align your forehead at the mark';
            stableIndicator.classList.remove('stable', 'capturing');
          }
        }

        this.drawLiveView(center, axisX, axisY, foreheadCenter, foreheadTargetY, foreheadAligned, state.alignmentHoldFrames / PUPIL_HOLD_FRAMES);
      },

      drawLiveView(ctr, axX, axY, fCenter, fTargetY, fAligned, progress) {
        ctx.clearRect(0, 0, W, H);
       
        ctx.strokeStyle = 'rgba(130, 190, 255, 0.9)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.ellipse(ctr[0], ctr[1], axX, axY, 0, 0, Math.PI * 2);
        ctx.stroke();

        const targetColor = fAligned ? '#00ff00' : '#ffff00';
        const targetSize = 10;
       
        ctx.strokeStyle = targetColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(ctr[0] - targetSize, fTargetY);
        ctx.lineTo(ctr[0] + targetSize, fTargetY);
        ctx.moveTo(ctr[0], fTargetY - targetSize);
        ctx.lineTo(ctr[0], fTargetY + targetSize);
        ctx.stroke();

        if (fCenter) {
          ctx.fillStyle = fAligned ? '#00ff00' : '#f44336';
          ctx.beginPath();
          ctx.arc(fCenter[0], fCenter[1], 5, 0, Math.PI * 2);
          ctx.fill();
        }

        // Progress bar
        if (progress > 0) {
          const barWidth = 300;
          const barHeight = 20;
          const barX = (W - barWidth) / 2;
          const barY = H - 80;
         
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
         
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.strokeRect(barX, barY, barWidth, barHeight);
         
          ctx.fillStyle = '#4CAF50';
          ctx.fillRect(barX, barY, barWidth * progress, barHeight);
         
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 12px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText(`${Math.round(progress * 100)}%`, W / 2, barY + 15);
          ctx.textAlign = 'left';
        }

        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = '14px system-ui';
        ctx.fillText('Align and hold steady - auto-capture in 3 seconds', W/2 - 180, H - 20);
      },

      processPhotoMode(lm) {
        const detectedLeft = this.calculatePupilCenter(lm, this.LEFT_IRIS_INDICES);
        const detectedRight = this.calculatePupilCenter(lm, this.RIGHT_IRIS_INDICES);
       
        const finalLeft = this.manualLeftPupil || detectedLeft;
        const finalRight = this.manualRightPupil || detectedRight;

        const leftIrisPx = this.dist([lm[469].x * W, lm[469].y * H], [lm[471].x * W, lm[471].y * H]);
        const rightIrisPx = this.dist([lm[474].x * W, lm[474].y * H], [lm[476].x * W, lm[476].y * H]);
        const irisDiameterPx = (leftIrisPx + rightIrisPx) / 2;
       
        const irisPx = irisDiameterPx;
        const scaleToUse = irisPx > 0 ? this.IRIS_REAL_MM / irisPx : 0.1;

        const ipdMm = this.dist(finalLeft, finalRight) * scaleToUse;

        const noseCenter = [lm[1].x * W, lm[1].y * H];
        const eyeLineY = (finalLeft[1] + finalRight[1]) / 2;
        const noseLinePoint = [noseCenter[0], eyeLineY];

        const leftNoseMm = this.dist(finalLeft, noseLinePoint) * scaleToUse;
        const rightNoseMm = this.dist(finalRight, noseLinePoint) * scaleToUse;

        const headTiltDeg = Math.atan2(finalRight[1] - finalLeft[1], finalRight[0] - finalLeft[0]) * 180 / Math.PI;
        const distanceMm = irisPx > 0 ? Math.round((this.IRIS_REAL_MM * this.FOCAL_PX) / irisPx) : null;

        const isAccurate = this.validatePupilDetection(lm, finalLeft, finalRight);

        state.lastMeasurement = {
          pd: Math.round(ipdMm),
          leftNose: Math.round(leftNoseMm),
          rightNose: Math.round(rightNoseMm),
          tilt: Math.round(headTiltDeg),
          distance: distanceMm,
          accuracy: isAccurate ? 'High' : 'Medium'
        };

        this.drawPhotoMode(finalLeft, finalRight, noseLinePoint, ipdMm, leftNoseMm, rightNoseMm, headTiltDeg, distanceMm, isAccurate);
       
        log(`PD: ${Math.round(ipdMm)} mm | Lâ†’N: ${Math.round(leftNoseMm)} mm | Râ†’N: ${Math.round(rightNoseMm)} mm`);
      },

      drawPhotoMode(fL, fR, nose, pd, lNose, rNose, tilt, dist, isAccurate) {
        ctx.clearRect(0, 0, W, H);

        const lm = state.capturedLandmarks;
        if (!lm) return;
       
        const leftIrisPx = this.dist([lm[469].x * W, lm[469].y * H], [lm[471].x * W, lm[471].y * H]);
        const rightIrisPx = this.dist([lm[474].x * W, lm[474].y * H], [lm[476].x * W, lm[476].y * H]);
        const irisDiameterPx = (leftIrisPx + rightIrisPx) / 2;
       
        const irisRadiusPx = irisDiameterPx / 2;
        const crossSize = irisRadiusPx * 0.15;

        if (nose) {
          ctx.strokeStyle = 'rgba(255,255,0,0.8)';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(0, nose[1]);
          ctx.lineTo(W, nose[1]);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        const crossColor = isAccurate ? '#00ff00' : '#ffaa00';
        ctx.strokeStyle = crossColor;
        ctx.lineWidth = 3;
       
        if (fL) {
          ctx.beginPath();
          ctx.moveTo(fL[0] - crossSize, fL[1]);
          ctx.lineTo(fL[0] + crossSize, fL[1]);
          ctx.moveTo(fL[0], fL[1] - crossSize);
          ctx.lineTo(fL[0], fL[1] + crossSize);
          ctx.stroke();
         
          ctx.fillStyle = crossColor;
          ctx.beginPath();
          ctx.arc(fL[0], fL[1], 3, 0, Math.PI * 2);
          ctx.fill();
        }
       
        if (fR) {
          ctx.beginPath();
          ctx.moveTo(fR[0] - crossSize, fR[1]);
          ctx.lineTo(fR[0] + crossSize, fR[1]);
          ctx.moveTo(fR[0], fR[1] - crossSize);
          ctx.lineTo(fR[0], fR[1] + crossSize);
          ctx.stroke();
         
          ctx.fillStyle = crossColor;
          ctx.beginPath();
          ctx.arc(fR[0], fR[1], 3, 0, Math.PI * 2);
          ctx.fill();
        }
       
        if (fL && fR) {
          ctx.strokeStyle = 'rgba(255,0,0,0.6)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(fL[0], fL[1]);
          ctx.lineTo(fR[0], fR[1]);
          ctx.stroke();
        }

        ctx.fillStyle = isAccurate ? 'rgba(0, 255, 0, 0.95)' : 'rgba(255, 165, 0, 0.95)';
        ctx.font = 'bold 14px system-ui';
        ctx.fillText(isAccurate ? 'âœ“ High Accuracy' : 'âš  Medium Accuracy', 20, H - 45);

        const man = [];
        if (this.manualLeftPupil) man.push("L");
        if (this.manualRightPupil) man.push("R");
        if (man.length) {
          ctx.fillStyle = '#000000';
          ctx.font = 'bold 14px system-ui';
          ctx.fillText("Manual: " + man.join(","), W - 150, 30);
        }

        ctx.fillStyle = '#000000';
        ctx.font = 'bold 20px system-ui';
        ctx.fillText(`PD: ${Math.round(pd)} mm`, 20, 35);
       
        ctx.font = '16px system-ui';
        ctx.fillText(`Leftâ†’Nose: ${Math.round(lNose)} mm`, 20, 65);
        ctx.fillText(`Rightâ†’Nose: ${Math.round(rNose)} mm`, 20, 90);
        ctx.fillText(`Tilt: ${Math.round(tilt)}Â°`, 20, 115);
        if (dist) {
          ctx.fillText(`Distance: ${dist} mm`, 20, 140);
        }

        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = '14px system-ui';
        ctx.fillText('Drag crosses to adjust | Press R to reset | Click Retake for new photo', 20, H - 20);
      },

      reset() {
        this.manualLeftPupil = null;
        this.manualRightPupil = null;
      }
    };

    // ==================== FRAME FITTER ====================
    const frameFitter = {
      landmarks: null,
      pixelsPerMm: null,
      leftFrame: { top: null, bottom: null, left: null, right: null },
      rightFrame: { top: null, bottom: null, left: null, right: null },
      activeFrame: 'left',
      dragging: null,
      dragOffset: [0, 0],

      dist(a, b) {
        if (!a || !b) return 0;
        return Math.hypot(a[0] - b[0], a[1] - b[1]);
      },

      processLiveView(lm) {
        if (!this.pixelsPerMm) {
          const lIn = [lm[133].x * W, lm[133].y * H];
          const rIn = [lm[362].x * W, lm[362].y * H];
          const ipdPx = this.dist(lIn, rIn);
          if (ipdPx > 0) {
            this.pixelsPerMm = ipdPx / 63.0;
          }
        }

        const stableIndicator = document.getElementById('frame-stable');
       
        if (this.pixelsPerMm && !state.autoCapturing) {
          state.alignmentHoldFrames++;
          const progress = Math.min(100, (state.alignmentHoldFrames / FRAME_HOLD_FRAMES) * 100);
         
          if (state.alignmentHoldFrames >= FRAME_HOLD_FRAMES) {
            state.autoCapturing = true;
            stableIndicator.textContent = 'ðŸ“¸ Capturing...';
            stableIndicator.classList.add('capturing');
            setTimeout(() => {
              capturePhoto();
              state.autoCapturing = false;
              state.alignmentHoldFrames = 0;
            }, 100);
          } else {
            stableIndicator.textContent = `Hold steady... ${Math.round(progress)}%`;
            stableIndicator.classList.add('stable');
          }
        } else {
          state.alignmentHoldFrames = 0;
          if (!state.autoCapturing) {
            stableIndicator.textContent = 'Keep stable';
            stableIndicator.classList.remove('stable', 'capturing');
          }
        }

        this.drawLiveView(state.alignmentHoldFrames / FRAME_HOLD_FRAMES);
      },

      drawLiveView(progress) {
        ctx.clearRect(0, 0, W, H);
       
        // Progress bar
        if (progress > 0) {
          const barWidth = 300;
          const barHeight = 20;
          const barX = (W - barWidth) / 2;
          const barY = H - 80;
         
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
         
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.strokeRect(barX, barY, barWidth, barHeight);
         
          ctx.fillStyle = '#4CAF50';
          ctx.fillRect(barX, barY, barWidth * progress, barHeight);
         
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 12px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText(`${Math.round(progress * 100)}%`, W / 2, barY + 15);
          ctx.textAlign = 'left';
        }
       
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = '14px system-ui';
        ctx.fillText('Keep stable - auto-capture in 2 seconds', W/2 - 150, H - 20);
      },

      initLines(lm) {
        const lBrow = [lm[70].x * W, lm[70].y * H];
        const rBrow = [lm[300].x * W, lm[300].y * H];
        const lCheek = [lm[205].x * W, lm[205].y * H];
        const rCheek = [lm[425].x * W, lm[425].y * H];

        const topY = Math.min(lBrow[1], rBrow[1]) - 20;
        const botY = Math.max(lCheek[1], rCheek[1]) - 30;
       
        const frameWidth = 50;
        const leftEyeCenter = [lm[468].x * W, lm[468].y * H];
        const rightEyeCenter = [lm[473].x * W, lm[473].y * H];

        this.leftFrame.top = { x1: leftEyeCenter[0] - frameWidth/2, y1: topY, x2: leftEyeCenter[0] + frameWidth/2, y2: topY };
        this.leftFrame.bottom = { x1: leftEyeCenter[0] - frameWidth/2, y1: botY, x2: leftEyeCenter[0] + frameWidth/2, y2: botY };
        this.leftFrame.left = { x1: leftEyeCenter[0] - frameWidth/2, y1: topY, x2: leftEyeCenter[0] - frameWidth/2, y2: botY };
        this.leftFrame.right = { x1: leftEyeCenter[0] + frameWidth/2, y1: topY, x2: leftEyeCenter[0] + frameWidth/2, y2: botY };

        this.rightFrame.top = { x1: rightEyeCenter[0] - frameWidth/2, y1: topY, x2: rightEyeCenter[0] + frameWidth/2, y2: topY };
        this.rightFrame.bottom = { x1: rightEyeCenter[0] - frameWidth/2, y1: botY, x2: rightEyeCenter[0] + frameWidth/2, y2: botY };
        this.rightFrame.left = { x1: rightEyeCenter[0] - frameWidth/2, y1: topY, x2: rightEyeCenter[0] - frameWidth/2, y2: botY };
        this.rightFrame.right = { x1: rightEyeCenter[0] + frameWidth/2, y1: topY, x2: rightEyeCenter[0] + frameWidth/2, y2: botY };

        log('Frame lines initialized');
      },

      processPhotoMode(lm) {
        if (!this.leftFrame.top) {
          this.initLines(lm);
        }
        this.drawPhotoMode();
      },

      drawPhotoMode() {
        ctx.clearRect(0, 0, W, H);
        if (!this.leftFrame.top) return;

        const isLeftActive = this.activeFrame === 'left';
       
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.leftFrame.top.x1, this.leftFrame.top.y1);
        ctx.lineTo(this.leftFrame.top.x2, this.leftFrame.top.y2);
        ctx.lineTo(this.leftFrame.right.x2, this.leftFrame.right.y2);
        ctx.lineTo(this.leftFrame.bottom.x2, this.leftFrame.bottom.y2);
        ctx.lineTo(this.leftFrame.bottom.x1, this.leftFrame.bottom.y1);
        ctx.lineTo(this.leftFrame.left.x1, this.leftFrame.left.y1);
        ctx.closePath();
        ctx.stroke();

        ctx.fillStyle = isLeftActive ? '#00ff00' : 'rgba(0, 255, 0, 0.6)';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
       
        const leftHandles = [
          [this.leftFrame.top.x1, this.leftFrame.top.y1],
          [this.leftFrame.top.x2, this.leftFrame.top.y2],
          [this.leftFrame.bottom.x1, this.leftFrame.bottom.y1],
          [this.leftFrame.bottom.x2, this.leftFrame.bottom.y2]
        ];
       
        leftHandles.forEach(([x, y]) => {
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        });

        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.rightFrame.top.x1, this.rightFrame.top.y1);
        ctx.lineTo(this.rightFrame.top.x2, this.rightFrame.top.y2);
        ctx.lineTo(this.rightFrame.right.x2, this.rightFrame.right.y2);
        ctx.lineTo(this.rightFrame.bottom.x2, this.rightFrame.bottom.y2);
        ctx.lineTo(this.rightFrame.bottom.x1, this.rightFrame.bottom.y1);
        ctx.lineTo(this.rightFrame.left.x1, this.rightFrame.left.y1);
        ctx.closePath();
        ctx.stroke();

        ctx.fillStyle = !isLeftActive ? '#00ff00' : 'rgba(0, 255, 0, 0.6)';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
       
        const rightHandles = [
          [this.rightFrame.top.x1, this.rightFrame.top.y1],
          [this.rightFrame.top.x2, this.rightFrame.top.y2],
          [this.rightFrame.bottom.x1, this.rightFrame.bottom.y1],
          [this.rightFrame.bottom.x2, this.rightFrame.bottom.y2]
        ];
       
        rightHandles.forEach(([x, y]) => {
          ctx.beginPath();
          ctx.arc(x, y, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        });

        if (this.pixelsPerMm) {
          const leftWidth = this.dist(
            [this.leftFrame.top.x1, this.leftFrame.top.y1],
            [this.leftFrame.top.x2, this.leftFrame.top.y2]
          ) / this.pixelsPerMm;
         
          const leftHeight = this.dist(
            [this.leftFrame.left.x1, this.leftFrame.left.y1],
            [this.leftFrame.left.x2, this.leftFrame.left.y2]
          ) / this.pixelsPerMm;
         
          const rightWidth = this.dist(
            [this.rightFrame.top.x1, this.rightFrame.top.y1],
            [this.rightFrame.top.x2, this.rightFrame.top.y2]
          ) / this.pixelsPerMm;
         
          const rightHeight = this.dist(
            [this.rightFrame.left.x1, this.rightFrame.left.y1],
            [this.rightFrame.left.x2, this.rightFrame.left.y2]
          ) / this.pixelsPerMm;
         
          const bridgeW = this.dist(
            [this.leftFrame.right.x1, (this.leftFrame.right.y1 + this.leftFrame.right.y2) / 2],
            [this.rightFrame.left.x1, (this.rightFrame.left.y1 + this.rightFrame.left.y2) / 2]
          ) / this.pixelsPerMm;

          ctx.fillStyle = 'rgba(255,255,0,0.95)';
          ctx.font = 'bold 20px system-ui';
          ctx.fillText(`Left: ${Math.round(leftWidth)}Ã—${Math.round(leftHeight)} mm`, 20, 35);
         
          ctx.font = '16px system-ui';
          ctx.fillText(`Right: ${Math.round(rightWidth)}Ã—${Math.round(rightHeight)} mm`, 20, 65);
          ctx.fillText(`Bridge: ${Math.round(bridgeW)} mm`, 20, 95);

          state.lastMeasurement = {
            leftWidth: Math.round(leftWidth),
            leftHeight: Math.round(leftHeight),
            rightWidth: Math.round(rightWidth),
            rightHeight: Math.round(rightHeight),
            bridge: Math.round(bridgeW)
          };
        }

        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = '14px system-ui';
        ctx.fillText(`Drag corners to adjust ${this.activeFrame.toUpperCase()} frame | Toggle to switch | Retake for new photo`, 20, H - 20);

        ctx.fillStyle = '#ffff00';
        ctx.font = 'bold 16px system-ui';
        ctx.fillText(`Active: ${this.activeFrame.toUpperCase()} Frame`, W - 200, 30);
      },

      toggleFrame() {
        this.activeFrame = this.activeFrame === 'left' ? 'right' : 'left';
        const btn = document.getElementById('toggle-frame');
        btn.textContent = `Toggle Frame (${this.activeFrame === 'left' ? 'Left' : 'Right'})`;
        log(`Switched to ${this.activeFrame} frame`);
      },

      reset() {
        this.leftFrame = { top: null, bottom: null, left: null, right: null };
        this.rightFrame = { top: null, bottom: null, left: null, right: null };
        this.pixelsPerMm = null;
        this.activeFrame = 'left';
        log('Frame lines reset');
      }
    };

    // ==================== CAMERA & MEDIAPIPE ====================
    async function startCamera() {
      if (state.running) return;
      state.running = true;
      state.photoMode = false;
      state.alignmentHoldFrames = 0;
      state.autoCapturing = false;
      log('Starting camera...');

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: W,
            height: H,
            facingMode: state.currentCamera
          }
        });
        video.srcObject = stream;
        video.style.display = 'block';
        capturedImg.style.display = 'none';

        document.getElementById(`switch-camera-${state.currentTab}`).disabled = false;

        video.onloadedmetadata = async () => {
          log('Initializing MediaPipe Face Mesh...');
         
          state.faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
          });
         
          state.faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6,
            selfieMode: state.currentCamera === 'user'
          });
         
          state.faceMesh.onResults((results) => {
            if (!state.running) return;
           
            if (state.photoMode) {
              if (state.capturedLandmarks) {
                if (state.currentTab === 'pupil') {
                  pupilDetector.processPhotoMode(state.capturedLandmarks);
                } else {
                  frameFitter.processPhotoMode(state.capturedLandmarks);
                }
              }
            } else {
              if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const lm = results.multiFaceLandmarks[0];
                if (state.currentTab === 'pupil') {
                  pupilDetector.processLiveView(lm);
                } else {
                  frameFitter.processLiveView(lm);
                }
              } else {
                state.alignmentHoldFrames = 0;
              }
            }
          });

          const processFrame = async () => {
            if (state.running && video.readyState === 4) {
              if (!state.photoMode) {
                await state.faceMesh.send({ image: video });
              }
              state.animationId = requestAnimationFrame(processFrame);
            }
          };
         
          await state.faceMesh.initialize();
          log(`Camera ready (${state.currentCamera === 'user' ? 'Front' : 'Back'})`);
          processFrame();
        };
      } catch (e) {
        log('Camera error: ' + e.message);
        state.running = false;
      }
    }

    function stopCamera() {
      if (!state.running) return;
      state.running = false;
      state.photoMode = false;
      state.alignmentHoldFrames = 0;
      state.autoCapturing = false;
      state.capturedLandmarks = null;
      log('Stopping camera...');
     
      if (state.animationId) {
        cancelAnimationFrame(state.animationId);
        state.animationId = null;
      }
     
      if (state.faceMesh) {
        state.faceMesh.close();
        state.faceMesh = null;
      }
     
      const stream = video.srcObject;
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        video.srcObject = null;
      }
     
      ctx.clearRect(0, 0, W, H);
      video.style.display = 'block';
      capturedImg.style.display = 'none';
     
      if (state.currentTab === 'pupil') {
        document.getElementById('retake-pupil').disabled = true;
        document.getElementById('retake-pupil').style.display = 'none';
        document.getElementById('save-pupil').disabled = true;
        document.getElementById('switch-camera-pupil').disabled = true;
        const indicator = document.getElementById('pupil-stable');
        indicator.textContent = 'Align your face';
        indicator.classList.remove('stable', 'capturing');
      } else {
        document.getElementById('retake-frame').disabled = true;
        document.getElementById('retake-frame').style.display = 'none';
        document.getElementById('save-frame').disabled = true;
        document.getElementById('toggle-frame').disabled = true;
        document.getElementById('switch-camera-frame').disabled = true;
        const indicator = document.getElementById('frame-stable');
        indicator.textContent = 'Keep stable';
        indicator.classList.remove('stable', 'capturing');
      }
     
      log('Camera stopped');
    }

    async function switchCamera() {
      if (!state.running) return;
     
      log('Switching camera...');
      state.currentCamera = state.currentCamera === 'user' ? 'environment' : 'user';
     
      stopCamera();
     
      setTimeout(() => {
        startCamera();
      }, 500);
    }

    async function capturePhoto() {
      if (!state.running) {
        log('Start camera first!');
        return;
      }

      log('Capturing photo...');
     
      const captureCanvas = document.createElement('canvas');
      captureCanvas.width = W;
      captureCanvas.height = H;
      const captureCtx = captureCanvas.getContext('2d');
      captureCtx.drawImage(video, 0, 0, W, H);
     
      const imageData = captureCanvas.toDataURL('image/png');
      capturedImg.src = imageData;
      state.capturedImage = imageData;
     
      const img = new Image();
      img.onload = async () => {
        const results = await new Promise((resolve) => {
          const tempFaceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${file}`
          });
         
          tempFaceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6,
            selfieMode: state.currentCamera === 'user'
          });
         
          tempFaceMesh.onResults((res) => {
            resolve(res);
            tempFaceMesh.close();
          });
         
          tempFaceMesh.initialize().then(() => {
            tempFaceMesh.send({ image: img });
          });
        });
       
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
          state.capturedLandmarks = results.multiFaceLandmarks[0];
         
          state.photoMode = true;
          video.style.display = 'none';
          capturedImg.style.display = 'block';
         
          if (state.currentTab === 'pupil') {
            pupilDetector.processPhotoMode(state.capturedLandmarks);
            document.getElementById('save-pupil').disabled = false;
            document.getElementById('retake-pupil').disabled = false;
            document.getElementById('retake-pupil').style.display = 'inline-block';
            const indicator = document.getElementById('pupil-stable');
            indicator.textContent = 'Photo captured! Adjust and save';
            indicator.classList.remove('capturing');
            indicator.classList.add('stable');
          } else {
            frameFitter.processPhotoMode(state.capturedLandmarks);
            document.getElementById('save-frame').disabled = false;
            document.getElementById('toggle-frame').disabled = false;
            document.getElementById('retake-frame').disabled = false;
            document.getElementById('retake-frame').style.display = 'inline-block';
            const indicator = document.getElementById('frame-stable');
            indicator.textContent = 'Photo captured! Adjust and save';
            indicator.classList.remove('capturing');
            indicator.classList.add('stable');
          }
         
          log('Photo captured! Adjust measurements and save result');
        } else {
          log('Failed to detect face. Please try again.');
          state.photoMode = false;
          state.alignmentHoldFrames = 0;
        }
      };
      img.src = imageData;
    }

    function retakePhoto() {
      log('Retaking photo...');
     
      if (state.currentTab === 'pupil') {
        pupilDetector.reset();
        document.getElementById('retake-pupil').disabled = true;
        document.getElementById('retake-pupil').style.display = 'none';
        document.getElementById('save-pupil').disabled = true;
        const indicator = document.getElementById('pupil-stable');
        indicator.textContent = 'Align your face';
        indicator.classList.remove('stable', 'capturing');
      } else {
        frameFitter.reset();
        document.getElementById('retake-frame').disabled = true;
        document.getElementById('retake-frame').style.display = 'none';
        document.getElementById('save-frame').disabled = true;
        document.getElementById('toggle-frame').disabled = true;
        const indicator = document.getElementById('frame-stable');
        indicator.textContent = 'Keep stable';
        indicator.classList.remove('stable', 'capturing');
      }
     
      state.photoMode = false;
      state.capturedLandmarks = null;
      state.capturedImage = null;
      state.alignmentHoldFrames = 0;
      state.autoCapturing = false;
     
      video.style.display = 'block';
      capturedImg.style.display = 'none';
      ctx.clearRect(0, 0, W, H);
    }

    function saveResult() {
      if (!state.photoMode || !state.capturedImage) {
        log('Capture a photo first!');
        return;
      }
     
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = W;
      tempCanvas.height = H;
      const tempCtx = tempCanvas.getContext('2d');
     
      tempCtx.drawImage(capturedImg, 0, 0, W, H);
      tempCtx.drawImage(canvas, 0, 0);
     
      tempCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      tempCtx.fillRect(0, H - 120, W, 120);
     
      tempCtx.fillStyle = '#ffffff';
      tempCtx.font = 'bold 18px system-ui';
     
      if (state.currentTab === 'pupil' && state.lastMeasurement) {
        const m = state.lastMeasurement;
        tempCtx.fillText(`PD: ${m.pd} mm`, 20, H - 90);
        tempCtx.fillText(`Leftâ†’Nose: ${m.leftNose} mm | Rightâ†’Nose: ${m.rightNose} mm`, 20, H - 65);
        tempCtx.fillText(`Tilt: ${m.tilt}Â° | Distance: ${m.distance} mm`, 20, H - 40);
        tempCtx.font = '14px system-ui';
        tempCtx.fillText(`Timestamp: ${new Date().toLocaleString()}`, 20, H - 15);
      } else if (state.currentTab === 'frame' && state.lastMeasurement) {
        const m = state.lastMeasurement;
        tempCtx.fillText(`Left: ${m.leftWidth}Ã—${m.leftHeight} mm | Right: ${m.rightWidth}Ã—${m.rightHeight} mm`, 20, H - 90);
        tempCtx.fillText(`Bridge: ${m.bridge} mm`, 20, H - 65);
        tempCtx.font = '14px system-ui';
        tempCtx.fillText(`Timestamp: ${new Date().toLocaleString()}`, 20, H - 40);
      }
     
      tempCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${state.currentTab}_measurement_${Date.now()}.png`;
        a.click();
        URL.revokeObjectURL(url);
        log(`Saved: ${a.download}`);
      });
    }

    // ==================== MOUSE EVENTS ====================
    canvas.addEventListener('mousedown', (e) => {
      if (!state.photoMode) return;
     
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (W / rect.width);
      const y = (e.clientY - rect.top) * (H / rect.height);

      if (state.currentTab === 'pupil') {
        const autoLeft = [state.capturedLandmarks[468].x * W, state.capturedLandmarks[468].y * H];
        const autoRight = [state.capturedLandmarks[473].x * W, state.capturedLandmarks[473].y * H];
        const finalLeft = pupilDetector.manualLeftPupil || autoLeft;
        const finalRight = pupilDetector.manualRightPupil || autoRight;
       
        if (pupilDetector.dist([x, y], finalLeft) < 30) {
          pupilDetector.selectedEye = 'left';
          pupilDetector.manualLeftPupil = [...finalLeft];
          pupilDetector.isDragging = true;
        } else if (pupilDetector.dist([x, y], finalRight) < 30) {
          pupilDetector.selectedEye = 'right';
          pupilDetector.manualRightPupil = [...finalRight];
          pupilDetector.isDragging = true;
        }
      } else {
        if (!frameFitter.leftFrame.top) return;
       
        const leftHandles = [
          { name: 'left-top-left', frame: 'left', pos: [frameFitter.leftFrame.top.x1, frameFitter.leftFrame.top.y1] },
          { name: 'left-top-right', frame: 'left', pos: [frameFitter.leftFrame.top.x2, frameFitter.leftFrame.top.y2] },
          { name: 'left-bottom-left', frame: 'left', pos: [frameFitter.leftFrame.bottom.x1, frameFitter.leftFrame.bottom.y1] },
          { name: 'left-bottom-right', frame: 'left', pos: [frameFitter.leftFrame.bottom.x2, frameFitter.leftFrame.bottom.y2] }
        ];
       
        const rightHandles = [
          { name: 'right-top-left', frame: 'right', pos: [frameFitter.rightFrame.top.x1, frameFitter.rightFrame.top.y1] },
          { name: 'right-top-right', frame: 'right', pos: [frameFitter.rightFrame.top.x2, frameFitter.rightFrame.top.y2] },
          { name: 'right-bottom-left', frame: 'right', pos: [frameFitter.rightFrame.bottom.x1, frameFitter.rightFrame.bottom.y1] },
          { name: 'right-bottom-right', frame: 'right', pos: [frameFitter.rightFrame.bottom.x2, frameFitter.rightFrame.bottom.y2] }
        ];

        const allHandles = [...leftHandles, ...rightHandles];

        for (const h of allHandles) {
          if (frameFitter.dist([x, y], h.pos) < 20) {
            frameFitter.dragging = h.name;
            frameFitter.activeFrame = h.frame;
            frameFitter.dragOffset = [x - h.pos[0], y - h.pos[1]];
           
            const btn = document.getElementById('toggle-frame');
            btn.textContent = `Toggle Frame (${frameFitter.activeFrame === 'left' ? 'Left' : 'Right'})`;
            break;
          }
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!state.photoMode) return;
     
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (W / rect.width);
      const y = (e.clientY - rect.top) * (H / rect.height);

      if (state.currentTab === 'pupil' && pupilDetector.isDragging) {
        if (pupilDetector.selectedEye === 'left') {
          pupilDetector.manualLeftPupil = [x, y];
        } else if (pupilDetector.selectedEye === 'right') {
          pupilDetector.manualRightPupil = [x, y];
        }
        pupilDetector.processPhotoMode(state.capturedLandmarks);
      } else if (state.currentTab === 'frame' && frameFitter.dragging) {
        const isDraggingLeft = frameFitter.dragging.startsWith('left-');
        const currentFrame = isDraggingLeft ? frameFitter.leftFrame : frameFitter.rightFrame;
        const handleType = frameFitter.dragging.split('-').slice(-2).join('-');
       
        const nx = x - frameFitter.dragOffset[0];
        const ny = y - frameFitter.dragOffset[1];

        switch (handleType) {
          case 'top-left':
            currentFrame.top.x1 = nx;
            currentFrame.top.y1 = ny;
            currentFrame.left.x1 = nx;
            currentFrame.left.y1 = ny;
            currentFrame.bottom.x1 = nx;
            break;
          case 'top-right':
            currentFrame.top.x2 = nx;
            currentFrame.top.y2 = ny;
            currentFrame.right.x1 = nx;
            currentFrame.right.y1 = ny;
            currentFrame.bottom.x2 = nx;
            break;
          case 'bottom-left':
            currentFrame.bottom.x1 = nx;
            currentFrame.bottom.y1 = ny;
            currentFrame.left.x2 = nx;
            currentFrame.left.y2 = ny;
            currentFrame.top.x1 = nx;
            break;
          case 'bottom-right':
            currentFrame.bottom.x2 = nx;
            currentFrame.bottom.y2 = ny;
            currentFrame.right.x2 = nx;
            currentFrame.right.y2 = ny;
            currentFrame.top.x2 = nx;
            break;
        }
        frameFitter.processPhotoMode(state.capturedLandmarks);
      }
    });

    canvas.addEventListener('mouseup', () => {
      pupilDetector.selectedEye = null;
      pupilDetector.isDragging = false;
      frameFitter.dragging = null;
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      canvas.dispatchEvent(new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
      }));
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      canvas.dispatchEvent(new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
      }));
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      canvas.dispatchEvent(new MouseEvent('mouseup'));
    });

    // ==================== BUTTON EVENTS ====================
    document.getElementById('start-pupil').addEventListener('click', () => {
      state.currentTab = 'pupil';
      pupilDetector.reset();
      startCamera();
    });

    document.getElementById('stop-pupil').addEventListener('click', stopCamera);
    document.getElementById('switch-camera-pupil').addEventListener('click', switchCamera);
    document.getElementById('retake-pupil').addEventListener('click', retakePhoto);
    document.getElementById('save-pupil').addEventListener('click', saveResult);

    document.getElementById('reset-auto').addEventListener('click', () => {
      pupilDetector.reset();
      log('Reset manual adjustments');
      if (state.photoMode && state.capturedLandmarks) {
        pupilDetector.processPhotoMode(state.capturedLandmarks);
      }
    });

    document.getElementById('start-frame').addEventListener('click', () => {
      state.currentTab = 'frame';
      frameFitter.reset();
      startCamera();
    });

    document.getElementById('stop-frame').addEventListener('click', stopCamera);
    document.getElementById('switch-camera-frame').addEventListener('click', switchCamera);
    document.getElementById('retake-frame').addEventListener('click', retakePhoto);
    document.getElementById('save-frame').addEventListener('click', saveResult);

    document.getElementById('toggle-frame').addEventListener('click', () => {
      frameFitter.toggleFrame();
      if (state.photoMode && state.capturedLandmarks) {
        frameFitter.processPhotoMode(state.capturedLandmarks);
      }
    });

    document.getElementById('reset-frame').addEventListener('click', () => {
      frameFitter.reset();
      if (state.photoMode && state.capturedLandmarks) {
        frameFitter.processPhotoMode(state.capturedLandmarks);
      } else {
        log('Frame lines will be reset on next capture');
      }
    });

    document.addEventListener('keydown', (e) => {
      if (!state.running) return;
      if (state.currentTab === 'pupil' && state.photoMode) {
        if (e.key.toLowerCase() === 'r') {
          pupilDetector.reset();
          log('Reset manual adjustments');
          if (state.capturedLandmarks) {
            pupilDetector.processPhotoMode(state.capturedLandmarks);
          }
        }
      }
      if (e.key === 'Escape') {
        stopCamera();
      }
    });

    log('OptiFocus ready. Start camera to begin auto-capture measurement.');
  </script>
</body>
</html>